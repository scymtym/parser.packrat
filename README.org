#+TITLE: parser.packrat README
#+AUTHOR: Jan Moringen
#+EMAIL: jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+SEQ_TODO: TODO STARTED | DONE

#+SETUPFILE: org-html-themes-master/setup/theme-readtheorg-local.setup

* STARTED Introduction

  The ~parser.packrat~ system provides an extensible framework for
  efficient parsing and pattern matching on different kinds of
  inputs.

  Aspects of this system are inspired by OMeta, [[https://github.com/my2m/optima][optima,]] and [[https://github.com/scymtym/esrap][esrap]].

  Modular/composable grammars

  Support for the following kinds of inputs is built in:

  + Sequences

    + Lists

    + Vectors

      + of character (i.e. strings)

      + of octets

      + of bit

  + Streams

    + of octets

    + of characters

  + Objects and structures

  + Trees

* STARTED Tutorial

  #+BEGIN_SRC lisp :exports results :results silent
    (ql:quickload '(:parser.packrat :parser.packrat.grammar.string))
  #+END_SRC

  The fundamental concepts are

  + /expressions/ such as src_lisp[:exports code]{(:seq (or #\a #\b)
    #\c)}

  + /rules/ which are named expressions, optionally accepting
    parameters and optionally transforming the parse result before
    returning it

  + /grammars/ which are named collections of rules tied to a
    particular kind of input. Grammars can extend other grammars and
    rules in one grammar can invoke rules in other grammars.

  Defining a grammar

  #+BEGIN_SRC lisp :exports both
    (parser.packrat:defgrammar :integers
      (:class parser.packrat.grammar.string:simple-string-grammar))
    (parser.packrat:in-grammar :integers)
  #+END_SRC

  #+RESULTS:
  : #<SIMPLE-STRING-GRAMMAR INTEGERS 0 rules {10036A19A3}>

  Defining rules

  #+BEGIN_SRC lisp :exports both
    (parser.packrat:defrule digit (base)
        (:<- char)
      (or (digit-char-p char base) (:fail)))

    (parser.packrat:defrule integer (base)
        (* (:<<- digits (digit base)) 1)
      (loop :for digit :in digits
            :for weight = 1 :then (* base weight)
            :sum (* weight digit)))
  #+END_SRC

  #+RESULTS:
  : #<RULE INTEGER {205B9F0B}>

  Applying rules to inputs

  #+BEGIN_SRC lisp :exports both :colnames '("input" "base" "success?" "consumed" "value")
    (list (list* #1="1234" #2=10 (multiple-value-list (parser.packrat:parse '((integer :integers) #2#) #1#)))
          (list* #3="bee"  #4=16 (multiple-value-list (parser.packrat:parse '((integer :integers) #4#) #3#))))
  #+END_SRC

  #+RESULTS:
  | input | base | success? | consumed | value |
  |-------+------+----------+----------+-------|
  | 1234  |   10 | T        |        4 |  1234 |
  | beef  |   16 | T        |        4 | 48879 |

* STARTED Project Organization

  + =src= :: Source code

    + =grammar= :: Grammar protocols

      + =sexp= :: S-expression grammar

  + =test= :: Unit tests

  + =examples= :: Examples

    + =types and programming languages= :: Solutions to some of the
         exercises of the book, obviously using a parsing- and
         pattern-matching-heavy style.

  + =documentation= :: Documentation

* STARTED Reference

  #+BEGIN_SRC lisp :exports results :results silent
    (defun print-expression-ast (expression)
      (parser.packrat.expression:walk-expression
       (lambda (recurse node)
         (let ((kind     (architecture.builder-protocol:node-kind* node))
               (initargs (architecture.builder-protocol:node-initargs* node)))
          (case kind
            ((:compose)
             (first (first (funcall recurse))))
            ((:transform :compose :set :push)
             (first (funcall recurse)))
            (:anything
             "«anything»")
            ((:terminal :constant)
             (let ((value (getf initargs :value)))
               (typecase value
                 ((and symbol (not keyword)) `',value)
                 (t                          value))))
            ((:predicate)
             (list :guard (first (funcall recurse)) (getf initargs :predicate)))
            ((:and :or :not)
             (list* kind (first (funcall recurse))))
            (:rule-invocation
             (let* ((rule      (getf initargs :rule))
                    (reference (format nil "~~[[~(~A~)][~~~:*~(~A~)~~]] ~~" rule)))
               (list* reference (first (funcall recurse)))))
            (:as-list
             (list* 'list (second (first (funcall recurse)))))
            (:repetition
             (destructuring-bind (min max sub) (funcall recurse)
               (cond ((and (eql min 0) (eql max 1))
                       (list '? sub))
                     ((and (eql min 1) (null max))
                       (list '+ sub))
                     ((null min)
                       (list '* sub))
                     ((null max)
                       (list '* sub min))
                     (t
                       (list '* sub min max)))))
            (t
             (list* (class-name (class-of node)) (funcall recurse))))))
       (parser.packrat.bootstrap:parse expression)))

    (defun describe-grammar-class (name)
      (let* ((class        (find-class name))
             (meta-grammar (case name
                             (parser.packrat.grammar.base::base-grammar
                              (parser.packrat.grammar:find-grammar 'parser.packrat.grammar.base::meta-grammar))
                             (parser.packrat.grammar.sequence::sequence-grammar
                              (parser.packrat.grammar:find-grammar 'parser.packrat.grammar.sequence::meta-grammar))
                             (parser.packrat.grammar.sexp::sexp-grammar
                              (parser.packrat.grammar:find-grammar 'parser.packrat.grammar.sexp::meta-grammar))))
             (meta-rules   (parser.packrat.grammar:rules meta-grammar)))
        (let ((*print-right-margin* most-positive-fixnum))
          (format t "+ =~(~A~)= Grammar Class~2%~
                     ~3@T~A~2%~
                     ~:{~3@T+ <<~(~a~)>> ~~~:*~A ::= ~A~~~2%~}"
                  name (documentation class t)
                  (map 'list (lambda (rule)
                               (list (parser.packrat.grammar:name rule)
                                     (print-expression-ast
                                      (parser.packrat.grammar:expression rule))))
                       (sort meta-rules #'string< :key #'parser.packrat.grammar:name)))))
      (values))
  #+END_SRC

  #+BEGIN_SRC lisp :exports results :results output verbatim raw
    (describe-grammar-class 'parser.packrat.grammar.base::base-grammar)

    (describe-grammar-class 'parser.packrat.grammar.sequence::sequence-grammar)

    (describe-grammar-class 'parser.packrat.grammar.sexp::sexp-grammar)
  #+END_SRC

  #+RESULTS:
  + =base-grammar= Grammar Class

     NIL

     + <<and-expression>> ~AND-EXPRESSION ::= (LIST 'AND (REPETITION-EXPRESSION NIL NIL (~[[expression][~expression~]] ~)))~

     + <<anything-expression>> ~ANYTHING-EXPRESSION ::= (OR 'ANY 'ANY)~

     + <<compose-expression>> ~COMPOSE-EXPRESSION ::= (LIST 'COMPOSE (REPETITION-EXPRESSION NIL NIL (~[[expression][~expression~]] ~)))~

     + <<constant-expression>> ~CONSTANT-EXPRESSION ::= (OR (LIST 'QUOTE (ANYTHING-EXPRESSION)) (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)))~

     + <<expression>> ~EXPRESSION ::= (OR (~[[predicate-expression][~predicate-expression~]] ~) (~[[anything-expression][~anything-expression~]] ~) (~[[constant-expression][~constant-expression~]] ~) (~[[set-expression][~set-expression~]] ~) (~[[push-expression][~push-expression~]] ~) (~[[not-expression][~not-expression~]] ~) (~[[and-expression][~and-expression~]] ~) (~[[or-expression][~or-expression~]] ~) (~[[compose-expression][~compose-expression~]] ~) (~[[transform-expression][~transform-expression~]] ~) (~[[rule-invocation-expression][~rule-invocation-expression~]] ~) (~[[next-rule-invocation-expression][~next-rule-invocation-expression~]] ~))~

     + <<function-name-or-partial-application>> ~FUNCTION-NAME-OR-PARTIAL-APPLICATION ::= (OR (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (LIST (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (REST-EXPRESSION (ANYTHING-EXPRESSION))))~

     + <<next-rule-invocation-expression>> ~NEXT-RULE-INVOCATION-EXPRESSION ::= (LIST (OR 'NEXT-RULE 'NEXT-RULE) (REPETITION-EXPRESSION NIL NIL (~[[expression][~expression~]] ~)))~

     + <<not-expression>> ~NOT-EXPRESSION ::= (LIST 'NOT (~[[expression][~expression~]] ~))~

     + <<or-expression>> ~OR-EXPRESSION ::= (LIST 'OR (REPETITION-EXPRESSION NIL NIL (~[[expression][~expression~]] ~)))~

     + <<predicate-expression>> ~PREDICATE-EXPRESSION ::= (LIST 'GUARD (REPETITION-EXPRESSION (CONSTANT-EXPRESSION) (CONSTANT-EXPRESSION) (~[[expression][~expression~]] ~)) (REST-EXPRESSION (~[[function-name-or-partial-application][~function-name-or-partial-application~]] ~)))~

     + <<push-expression>> ~PUSH-EXPRESSION ::= (LIST (OR '<<- '<<-) (~[[variable-name][~variable-name~]] ~) (REPETITION-EXPRESSION (CONSTANT-EXPRESSION) (CONSTANT-EXPRESSION) (~[[expression][~expression~]] ~)))~

     + <<rule-invocation-expression>> ~RULE-INVOCATION-EXPRESSION ::= (LIST (OR (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (LIST (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)))) (REPETITION-EXPRESSION NIL NIL (~[[expression][~expression~]] ~)))~

     + <<set-expression>> ~SET-EXPRESSION ::= (OR (~[[variable-name][~variable-name~]] ~) (LIST (OR '<- '<-) (~[[variable-name][~variable-name~]] ~) (REPETITION-EXPRESSION (CONSTANT-EXPRESSION) (CONSTANT-EXPRESSION) (~[[expression][~expression~]] ~))))~

     + <<transform-expression>> ~TRANSFORM-EXPRESSION ::= (LIST 'TRANSFORM (~[[expression][~expression~]] ~) (REST-EXPRESSION (ANYTHING-EXPRESSION)))~

     + <<variable-name>> ~VARIABLE-NAME ::= (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION))~

  + =sequence-grammar= Grammar Class

     NIL

     + <<+-expression>> ~+-EXPRESSION ::= ((LIST '+ (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))~

     + <<?-expression>> ~?-EXPRESSION ::= ((LIST '? (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))~

     + <<bounds-expression>> ~BOUNDS-EXPRESSION ::= ((LIST 'BOUNDS (LIST (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION))) (REST-EXPRESSION (ANYTHING-EXPRESSION))) (~[[expression][~expression~]] ~))~

     + <<expression>> ~EXPRESSION ::= (OR (~[[anything-expression][~anything-expression~]] ~) (~[[constant-expression][~constant-expression~]] ~) (~[[repetition-expression][~repetition-expression~]] ~) (~[[sequence-expression][~sequence-expression~]] ~) (~[[?-expression][~?-expression~]] ~) (~[[+-expression][~+-expression~]] ~) (~[[bounds-expression][~bounds-expression~]] ~))~

     + <<repetition-expression>> ~REPETITION-EXPRESSION ::= (LIST '* (~[[expression][~expression~]] ~) (REPETITION-EXPRESSION (CONSTANT-EXPRESSION) (CONSTANT-EXPRESSION) (~[[expression][~expression~]] ~)) (REPETITION-EXPRESSION (CONSTANT-EXPRESSION) (CONSTANT-EXPRESSION) (~[[expression][~expression~]] ~)))~

     + <<sequence-expression>> ~SEQUENCE-EXPRESSION ::= (LIST (OR 'SEQ 'SEQ) (REPETITION-EXPRESSION NIL NIL (~[[expression][~expression~]] ~)))~

     + <<value-expression>> ~VALUE-EXPRESSION ::= ((LIST 'VALUE (LIST (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))) (~[[expression][~expression~]] ~))~

  + =sexp-grammar= Grammar Class

     A grammar class for matching Lisp objects.

      In particular, this grammar class adds constructs for matching
      lists (`list', `list*', `rest'), vectors (`vector', `vector*') and
      structures including conses (`structure', `cons').

      Rules defined in grammars of this class operate on objects but can
      switch to sequence-based processing using the `as-list' and
      `as-vector' constructs.

     + <<cons-expression>> ~CONS-EXPRESSION ::= ((LIST 'CONS (ANYTHING-EXPRESSION) (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))~

     + <<expression>> ~EXPRESSION ::= (OR (~[[anything-expression][~anything-expression~]] ~) (~[[constant-expression][~constant-expression~]] ~) (~[[transform-expression][~transform-expression~]] ~) (~[[repetition-expression][~repetition-expression~]] ~) (~[[sequence-expression][~sequence-expression~]] ~) (~[[structure-expression][~structure-expression~]] ~) (~[[list-elements-expression][~list-elements-expression~]] ~) (~[[rest-expression][~rest-expression~]] ~) (~[[vector-elements-expression][~vector-elements-expression~]] ~) (~[[list-expression][~list-expression~]] ~) (~[[list*-expression][~list*-expression~]] ~) (~[[vector-expression][~vector-expression~]] ~) (~[[vector*-expression][~vector*-expression~]] ~) (~[[cons-expression][~cons-expression~]] ~) (~[[value-expression][~value-expression~]] ~))~

     + <<list*-expression>> ~LIST*-EXPRESSION ::= ((LIST 'LIST* (REPETITION-EXPRESSION NIL NIL (AND (SEQUENCE-EXPRESSION ((ANYTHING-EXPRESSION) (ANYTHING-EXPRESSION))) (ANYTHING-EXPRESSION))) (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))~

     + <<list-elements-expression>> ~LIST-ELEMENTS-EXPRESSION ::= (LIST 'LIST-ELEMENTS (~[[expression][~expression~]] ~))~

     + <<list-expression>> ~LIST-EXPRESSION ::= ((LIST 'LIST (REST-EXPRESSION (ANYTHING-EXPRESSION))) (~[[expression][~expression~]] ~))~

     + <<object-expression>> ~OBJECT-EXPRESSION ::= ((LIST 'OBJECT (LIST (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))) (~[[expression][~expression~]] ~))~

     + <<rest-expression>> ~REST-EXPRESSION ::= (LIST 'REST (~[[expression][~expression~]] ~))~

     + <<structure-expression>> ~STRUCTURE-EXPRESSION ::= (LIST 'STRUCTURE (~[[expression][~expression~]] ~) (REPETITION-EXPRESSION NIL NIL (LIST (ANYTHING-EXPRESSION) (~[[expression][~expression~]] ~))))~

     + <<value-expression>> ~VALUE-EXPRESSION ::= ((LIST 'VALUE (LIST (PREDICATE-EXPRESSION (ANYTHING-EXPRESSION)) (~[[expression][~expression~]] ~))) (~[[expression][~expression~]] ~))~

     + <<vector*-expression>> ~VECTOR*-EXPRESSION ::= ((LIST 'VECTOR* (REST-EXPRESSION (ANYTHING-EXPRESSION))) (~[[expression][~expression~]] ~))~

     + <<vector-elements-expression>> ~VECTOR-ELEMENTS-EXPRESSION ::= (LIST 'VECTOR-ELEMENTS (~[[expression][~expression~]] ~))~

     + <<vector-expression>> ~VECTOR-EXPRESSION ::= ((LIST 'VECTOR (REST-EXPRESSION (ANYTHING-EXPRESSION))) (~[[expression][~expression~]] ~))~


* Related Work

  + OMeta ::

  + Ohm ::

  + clometa ::

  + Esrap ::

  + Stratego/Spoofax :: http://www.metaborg.org/en/latest/index.html
